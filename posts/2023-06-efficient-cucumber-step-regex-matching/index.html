<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Efficient Cucumber Step Regex Matching | DVLA Engineering</title><meta name=keywords content="Ruby,Cucumber,Regex,Testing,Today I Learned"><meta name=description content="How to utilise powerful regex to write better cucumber step definitions"><meta name=author content="Choon Meng Yap"><link rel=canonical href=https://dvla.github.io/posts/2023-06-efficient-cucumber-step-regex-matching/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://dvla.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dvla.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dvla.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://dvla.github.io/favicon/apple-touch-icon.png><link rel=mask-icon href=https://dvla.github.io/favicon/favicon-16x16.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-WH4N9FEEE8"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WH4N9FEEE8",{anonymize_ip:!1})}</script><meta property="og:title" content="Efficient Cucumber Step Regex Matching"><meta property="og:description" content="How to utilise powerful regex to write better cucumber step definitions"><meta property="og:type" content="article"><meta property="og:url" content="https://dvla.github.io/posts/2023-06-efficient-cucumber-step-regex-matching/"><meta property="og:image" content="https://dvla.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-07T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-07T00:00:00+00:00"><meta property="og:site_name" content="DVLA Engineering"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dvla.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Efficient Cucumber Step Regex Matching"><meta name=twitter:description content="How to utilise powerful regex to write better cucumber step definitions"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dvla.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Efficient Cucumber Step Regex Matching","item":"https://dvla.github.io/posts/2023-06-efficient-cucumber-step-regex-matching/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Efficient Cucumber Step Regex Matching","name":"Efficient Cucumber Step Regex Matching","description":"How to utilise powerful regex to write better cucumber step definitions","keywords":["Ruby","Cucumber","Regex","Testing","Today I Learned"],"articleBody":"TL:DR Avoid using Cucumber Expression if possible. Using the conventional regular expression Cucumber is key to more flexible, reusable and customisable test code.\nWhen writing cucumber step definitions, developers and testers often face difficulties capturing parameters in test steps while ensuring that the steps flow smoothly in natural English sentences.\nWithout a good knowledge of general regex, step definitions can appear clunky, even when using Cucumber Expressions to capture step definitions parameters.\nCucumber Expressions Cucumber Expressions are more intuitive than regular expressions as they use a more generic expression to match a given parameter in a text.\nConsider the following Cucumber step:\nGiven a message of 'I like Cucumber' was added to the queue The step can be captured using the following Cucumber Expression in the step definition block:\nGiven('a message of {string} was added to the queue') do |message_text| ... end The {string} output parameter will extract the string message and pass it as an argument to the step definition.\nThis may seem fine, and the Cucumber Expression appears intuitive as we can understand what is being captured as a parameter in the text.\nIf we want to reuse the step definition to perform the same action of adding another message to the queue, we can easily change the step definition to capture alternative text.\nGiven('a/another message of {string} was added to the queue') do |message_text| ... end The slash / provides an option for the first word to be either a or another. Therefore, the updated Cucumber Expression would match the following two steps in a test scenario:\nGiven a message 'I like Cucumber' was added to the queue And another message 'I like Ruby' was added to the queue It’s important to note that Cucumber does not differentiate between Given, When, or Then in step beginnings; it captures them in the step definitions interchangeably.\nDespite the intuitiveness of Cucumber Expressions, we will propose using regular expressions as the more intelligent approach.\nRegular Expressions with Cucumber Cucumber supports using regular expressions in its step definitions since Cucumber Expressions are built on top of them to help us write step definitions in a more intuitive syntax.\nLet’s attempt to capture the above examples using the following regex in the step definition block:\nGiven(/^(a|another) message of '(.*)' was added to the queue$/) do |_unused, message_text| ... end The backslashes at the beginning and end of the text indicate a regex. The caret ^ at the beginning and the dollar sign $ at the end help avoid ambiguous matches (e.g. the regular expression /there is a message/ matches both there is a message and there is a message in the queue).\nNote that we need the single quotes around the (.*) to capture only the string and not the single quotes themselves. Also, there is an unused argument, _unused captured from the first capturing group. A capturing group is denoted by the surrounding round brackets in the regex.\nHere’s a quick summary of some common regex patterns:\nPatterns Definition .* matches any character (except for newline) between 0 or more times” .+ matches at least one of any character (except for line terminators) .? matches one or zero of any character (except for line terminators) ^ asserts position at start of a line $ asserts position at end of a line \\d matches a digit (equivalent to [0-9]) [A-Za-z]* matches letter ‘A’ to ‘Z’ or ‘a’ to ‘z’ between 0 or more times To simplify this regex better, we can update it to the following:\nGiven(/message of '(.*)' was added to the queue$/) do |message_text| ... end We could have used a non-capturing group by adding a ?: in the round brackets at the start of the group (e.g. (?:a|another)), but since we don’t care about preceding words and texts we can drop the group and the caret in the beginning.\nAs seen in the updated block above, using regex is much simpler and customisable compared to the Cucumber Expression we saw earlier. Our regex will now match any of the following:\nGiven the message of 'Regex is awesome' was added to the queue And another message of 'Regex is super awesome' was added to the queue And a special message of 'This is a special message' was added to the queue Why use regular expression over Cucumber Expression Ambiguous matching By dropping the caret and unnecessary words at the start of the regex text, we can provide ambiguous matching.\nStricter parameter capture Another benefit is that we can specify the format of the text to be captured. For example, we can replace (.*) with ([\\d-]*) to capture dates in the format 2023-01-01. We can even specify the exact number of characters using {10} instead of * to capture exactly 10 characters in our parameter.\nWe can be more specific about the format of the date by using the following regex:\nGiven(/date of '([\\d]{4}-{\\d}{2}-{\\d}{2})' was added to the schedule$/) do |date| ... end This will capture the following Cucumber step:\nGiven a date of '2023-01-01' was added to the schedule Doing this helps reduce errors in our tests and has the added benefit of reducing the need for additional validation on our captured parameters.\nNo need for passing parameters in single quotes or double quotes Using regular expressions eliminates the need to pass parameters in quotes when they are not necessary.\nFor example, consider the following step:\nGiven Alice, Bruce and Catherine are in a queue, in no particular order We can capture the text using a regex in the step definition:\nGiven(/^Alice, Bruce and Catherine are in a queue(, in no particular order)?$/) do |option| queue = ['Alice', 'Bruce', 'Catherine'] queue.shuffle! if option.present? end If instead we had opted for Cucumber expression, the step definition would look like this:\nGiven('Alice, Bruce and Catherine are in a queue{string})'/) do |option| queue = ['Alice', 'Bruce', 'Catherine'] queue.shuffle! if option.present? end Our step would then require quotes around the parameter to match the Cucumber expression:\nGiven Alice, Bruce and Catherine are in a queue\", in no particular order\" In this case, using regex in the step definition provides a smoother flow in the step, compared to using Cucumber Expression.\nAlthough there are cases where quotes are necessary to distinguish data parameters in the step, it is generally considered good practice. For example:\nGiven I fill in 'Alice' in the first name field Given the expiry date of the milk is on '2023-01-05' Don’t overuse regex - keep your step definitions simple and distinctive In cases where we have similar Given steps that we would like to match, it’s important to avoid overusing regex to prevent step definitions from becoming too complex and harder to understand.\nFor example, let’s consider the following steps:\nScenario: Checkout apples in basket Given there are 5 discounted apples in the basket ... Scenario: Checkout medicine in basket Given there are 2 cough medicines in the basket ... Both steps involve adding items to a basket, but the number of items and the item types are different. The apples are discounted.\nWe can match both steps with a single step definition using the following regex:\nGiven(/^there are (\\d*)( discounted)? (\\w*) in the basket$/) do |num_item, option, item_name| basket = Basket.new basket.inventory = basket.insert_into_basket(item_name:, num_item:, is_discounted: option.present?) end However, if the requirement states that medicines should never have discounts, it is important to separate the contexts and have two distinct step definitions:\nGiven(/^there are (\\d*) (discounted)? (\\w*) in the basket$/) do |num_item, option, item_name| basket = Basket.new basket.inventory = basket.insert_into_basket(item_name:, num_item:, is_discounted: option.present?) end Given(/^there are (\\d*) (\\w*) medicine in the basket$/) do |num_medicine, medicine_name| basket = Basket.new basket.inventory = basket.insert_into_basket(item_name: medicine_name, num_item: num_medicine) # we assume `is_discounted` has default boolean of false end This approach helps maintain simplicity in the code and avoids unnecessary complexity. If there are many test scenarios involving medicine in the basket, using separate step definitions will prevent repeated if logic and other logics in the code.\nConclusion Regular expressions provide several benefits compared to Cucumber Expressions, including flexibility to include options in the steps, stricter parameter capture, and the ability to avoid using quotes unnecessarily in step parameters.\nHowever, it is important to use regular expressions judiciously and avoid overcomplicating step definitions. Keeping step definitions simple and distinctive helps maintain code readability and understandability.\n","wordCount":"1380","inLanguage":"en","datePublished":"2023-06-07T00:00:00Z","dateModified":"2023-06-07T00:00:00Z","author":{"@type":"Person","name":"Choon Meng Yap"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dvla.github.io/posts/2023-06-efficient-cucumber-step-regex-matching/"},"publisher":{"@type":"Organization","name":"DVLA Engineering","logo":{"@type":"ImageObject","url":"https://dvla.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dvla.github.io/ accesskey=h title="DVLA Engineering (Alt + H)"><img src=https://dvla.github.io/favicon/apple-touch-icon.png alt aria-label=logo height=49>DVLA Engineering</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://dvla.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://dvla.github.io/open-source/ title=Open-source><span>Open-source</span></a></li><li><a href=https://github.com/dvla/ title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://www.civil-service-careers.gov.uk/departments/working-for-the-driver-and-vehicle-licensing-agency/ title=Careers><span>Careers</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dvla.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://dvla.github.io/posts/>Posts</a></div><h1 class=post-title>Efficient Cucumber Step Regex Matching</h1><div class=post-description>How to utilise powerful regex to write better cucumber step definitions</div><div class=post-meta><span title='2023-06-07 00:00:00 +0000 UTC'>June 7, 2023</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1380 words&nbsp;·&nbsp;Choon Meng Yap</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#cucumber-expressions>Cucumber Expressions</a></li><li><a href=#regular-expressions-with-cucumber>Regular Expressions with Cucumber</a></li><li><a href=#why-use-regular-expression-over-cucumber-expression>Why use regular expression over Cucumber Expression</a><ul><li><a href=#ambiguous-matching>Ambiguous matching</a></li><li><a href=#stricter-parameter-capture>Stricter parameter capture</a></li><li><a href=#no-need-for-passing-parameters-in-single-quotes-or-double-quotes>No need for passing parameters in single quotes or double quotes</a></li></ul></li><li><a href=#dont-overuse-regex---keep-your-step-definitions-simple-and-distinctive>Don&rsquo;t overuse regex - keep your step definitions simple and distinctive</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><p><strong>TL:DR Avoid using Cucumber Expression if possible. Using the conventional regular expression Cucumber is key to more flexible, reusable and customisable test code.</strong></p><p>When writing cucumber step definitions, developers and testers often face difficulties capturing parameters in test steps while ensuring that the steps flow smoothly in natural English sentences.</p><p>Without a good knowledge of general regex, step definitions can appear clunky, even when using <a href=https://github.com/cucumber/cucumber-expressions#readme>Cucumber Expressions</a> to capture step definitions parameters.</p><h2 id=cucumber-expressions>Cucumber Expressions<a hidden class=anchor aria-hidden=true href=#cucumber-expressions>#</a></h2><p>Cucumber Expressions are more intuitive than <a href=https://en.wikipedia.org/wiki/Regular_expression>regular expressions</a> as they use a more generic expression to match a given parameter in a text.</p><p>Consider the following Cucumber step:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cucumber data-lang=cucumber><span class=line><span class=cl><span class=k>Given </span><span class=nf>a message of &#39;I like Cucumber&#39; was added to the queue
</span></span></span></code></pre></div><p>The step can be captured using the following Cucumber Expression in the step definition block:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=no>Given</span><span class=p>(</span><span class=s1>&#39;a message of {string} was added to the queue&#39;</span><span class=p>)</span> <span class=k>do</span> <span class=o>|</span><span class=n>message_text</span><span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>The <code>{string}</code> output parameter will extract the string <code>message</code> and pass it as an argument to the step definition.</p><p>This may seem fine, and the Cucumber Expression appears intuitive as we can understand what is being captured as a parameter in the text.</p><p>If we want to reuse the step definition to perform the same action of adding another message to the queue, we can easily change the step definition to capture alternative text.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=no>Given</span><span class=p>(</span><span class=s1>&#39;a/another message of {string} was added to the queue&#39;</span><span class=p>)</span> <span class=k>do</span> <span class=o>|</span><span class=n>message_text</span><span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>The slash <code>/</code> provides an option for the first word to be either <code>a</code> or <code>another</code>. Therefore, the updated Cucumber Expression would match the following two steps in a test scenario:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cucumber data-lang=cucumber><span class=line><span class=cl><span class=k>Given </span><span class=nf>a message &#39;I like Cucumber&#39; was added to the queue
</span></span></span><span class=line><span class=cl><span class=nf></span><span class=k>And </span><span class=nf>another message &#39;I like Ruby&#39; was added to the queue
</span></span></span></code></pre></div><p>It&rsquo;s important to note that Cucumber does not differentiate between <code>Given</code>, <code>When</code>, or <code>Then</code> in step beginnings; it captures them in the step definitions interchangeably.</p><p>Despite the intuitiveness of Cucumber Expressions, we will propose using regular expressions as the more intelligent approach.</p><h2 id=regular-expressions-with-cucumber>Regular Expressions with Cucumber<a hidden class=anchor aria-hidden=true href=#regular-expressions-with-cucumber>#</a></h2><p>Cucumber supports using regular expressions in its step definitions since Cucumber Expressions are built on top of them to help us write step definitions in a more intuitive syntax.</p><p>Let&rsquo;s attempt to capture the above examples using the following regex in the step definition block:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=no>Given</span><span class=p>(</span><span class=sr>/^(a|another) message of &#39;(.*)&#39; was added to the queue$/</span><span class=p>)</span> <span class=k>do</span> <span class=o>|</span><span class=n>_unused</span><span class=p>,</span> <span class=n>message_text</span><span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>The backslashes at the beginning and end of the text indicate a regex. The caret <code>^</code> at the beginning and the dollar sign <code>$</code> at the end help avoid ambiguous matches (e.g. the regular expression <code>/there is a message/</code> matches both <code>there is a message</code> and <code>there is a message in the queue</code>).</p><p>Note that we need the single quotes around the <code>(.*)</code> to capture only the string and not the single quotes themselves. Also, there is an unused argument, <code>_unused</code> captured from the first capturing group. A capturing group is denoted by the surrounding round brackets in the regex.</p><p>Here&rsquo;s a quick summary of some common regex patterns:</p><table><thead><tr><th style=text-align:center>Patterns</th><th style=text-align:center>Definition</th></tr></thead><tbody><tr><td style=text-align:center><code>.*</code></td><td style=text-align:center>matches any character (except for newline) between 0 or more times”</td></tr><tr><td style=text-align:center><code>.+</code></td><td style=text-align:center>matches at least one of any character (except for line terminators)</td></tr><tr><td style=text-align:center><code>.?</code></td><td style=text-align:center>matches one or zero of any character (except for line terminators)</td></tr><tr><td style=text-align:center><code>^</code></td><td style=text-align:center>asserts position at start of a line</td></tr><tr><td style=text-align:center><code>$</code></td><td style=text-align:center>asserts position at end of a line</td></tr><tr><td style=text-align:center><code>\d</code></td><td style=text-align:center>matches a digit (equivalent to [0-9])</td></tr><tr><td style=text-align:center><code>[A-Za-z]*</code></td><td style=text-align:center>matches letter &lsquo;A&rsquo; to &lsquo;Z&rsquo; or &lsquo;a&rsquo; to &lsquo;z&rsquo; between 0 or more times</td></tr></tbody></table><p>To simplify this regex better, we can update it to the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=no>Given</span><span class=p>(</span><span class=sr>/message of &#39;(.*)&#39; was added to the queue$/</span><span class=p>)</span> <span class=k>do</span> <span class=o>|</span><span class=n>message_text</span><span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>We could have used a non-capturing group by adding a <code>?:</code> in the round brackets at the start of the group (e.g. <code>(?:a|another)</code>), but since we don&rsquo;t care about preceding words and texts we can drop the group and the caret in the beginning.</p><p>As seen in the updated block above, using regex is much simpler and customisable compared to the Cucumber Expression we saw earlier. Our regex will now match any of the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cucumber data-lang=cucumber><span class=line><span class=cl><span class=k>Given </span><span class=nf>the message of &#39;Regex is awesome&#39; was added to the queue
</span></span></span><span class=line><span class=cl><span class=nf></span><span class=k>And </span><span class=nf>another message of &#39;Regex is super awesome&#39; was added to the queue
</span></span></span><span class=line><span class=cl><span class=nf></span><span class=k>And </span><span class=nf>a special message of &#39;This is a special message&#39; was added to the queue
</span></span></span></code></pre></div><h2 id=why-use-regular-expression-over-cucumber-expression>Why use regular expression over Cucumber Expression<a hidden class=anchor aria-hidden=true href=#why-use-regular-expression-over-cucumber-expression>#</a></h2><h3 id=ambiguous-matching>Ambiguous matching<a hidden class=anchor aria-hidden=true href=#ambiguous-matching>#</a></h3><p>By dropping the caret and unnecessary words at the start of the regex text, we can provide ambiguous matching.</p><h3 id=stricter-parameter-capture>Stricter parameter capture<a hidden class=anchor aria-hidden=true href=#stricter-parameter-capture>#</a></h3><p>Another benefit is that we can specify the format of the text to be captured. For example, we can replace <code>(.*)</code> with <code>([\d-]*)</code> to capture dates in the format <code>2023-01-01</code>. We can even specify the exact number of characters using <code>{10}</code> instead of <code>*</code> to capture exactly 10 characters in our parameter.</p><p>We can be more specific about the format of the date by using the following regex:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=no>Given</span><span class=p>(</span><span class=sr>/date of &#39;([\d]{4}-{\d}{2}-{\d}{2})&#39; was added to the schedule$/</span><span class=p>)</span> <span class=k>do</span> <span class=o>|</span><span class=n>date</span><span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>This will capture the following Cucumber step:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cucumber data-lang=cucumber><span class=line><span class=cl><span class=k>Given </span><span class=nf>a date of &#39;</span><span class=s>2023</span><span class=nf>-</span><span class=s>01</span><span class=nf>-</span><span class=s>01</span><span class=nf>&#39; was added to the schedule
</span></span></span></code></pre></div><p>Doing this helps reduce errors in our tests and has the added benefit of reducing the need for additional validation on our captured parameters.</p><h3 id=no-need-for-passing-parameters-in-single-quotes-or-double-quotes>No need for passing parameters in single quotes or double quotes<a hidden class=anchor aria-hidden=true href=#no-need-for-passing-parameters-in-single-quotes-or-double-quotes>#</a></h3><p>Using regular expressions eliminates the need to pass parameters in quotes when they are not necessary.</p><p>For example, consider the following step:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cucumber data-lang=cucumber><span class=line><span class=cl><span class=k>Given </span><span class=nf>Alice, Bruce and Catherine are in a queue, in no particular order
</span></span></span></code></pre></div><p>We can capture the text using a regex in the step definition:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=no>Given</span><span class=p>(</span><span class=sr>/^Alice, Bruce and Catherine are in a queue(, in no particular order)?$/</span><span class=p>)</span> <span class=k>do</span> <span class=o>|</span><span class=n>option</span><span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=n>queue</span> <span class=o>=</span> <span class=o>[</span><span class=s1>&#39;Alice&#39;</span><span class=p>,</span> <span class=s1>&#39;Bruce&#39;</span><span class=p>,</span> <span class=s1>&#39;Catherine&#39;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=n>queue</span><span class=o>.</span><span class=n>shuffle!</span> <span class=k>if</span> <span class=n>option</span><span class=o>.</span><span class=n>present?</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>If instead we had opted for Cucumber expression, the step definition would look like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=no>Given</span><span class=p>(</span><span class=s1>&#39;Alice, Bruce and Catherine are in a queue{string})&#39;</span><span class=o>/</span><span class=p>)</span> <span class=k>do</span> <span class=o>|</span><span class=n>option</span><span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=n>queue</span> <span class=o>=</span> <span class=o>[</span><span class=s1>&#39;Alice&#39;</span><span class=p>,</span> <span class=s1>&#39;Bruce&#39;</span><span class=p>,</span> <span class=s1>&#39;Catherine&#39;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=n>queue</span><span class=o>.</span><span class=n>shuffle!</span> <span class=k>if</span> <span class=n>option</span><span class=o>.</span><span class=n>present?</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>Our step would then require quotes around the parameter to match the Cucumber expression:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cucumber data-lang=cucumber><span class=line><span class=cl><span class=k>Given </span><span class=nf>Alice, Bruce and Catherine are in a queue&#34;</span><span class=s>, in no particular order</span><span class=nf>&#34;
</span></span></span></code></pre></div><p>In this case, using regex in the step definition provides a smoother flow in the step, compared to using Cucumber Expression.</p><p>Although there are cases where quotes are necessary to distinguish data parameters in the step, it is generally considered good practice. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cucumber data-lang=cucumber><span class=line><span class=cl><span class=k>Given </span><span class=nf>I fill in &#39;Alice&#39; in the first name field
</span></span></span><span class=line><span class=cl><span class=nf>
</span></span></span><span class=line><span class=cl><span class=nf></span><span class=k>Given </span><span class=nf>the expiry date of the milk is on &#39;</span><span class=s>2023</span><span class=nf>-</span><span class=s>01</span><span class=nf>-</span><span class=s>05</span><span class=nf>&#39;
</span></span></span></code></pre></div><h2 id=dont-overuse-regex---keep-your-step-definitions-simple-and-distinctive>Don&rsquo;t overuse regex - keep your step definitions simple and distinctive<a hidden class=anchor aria-hidden=true href=#dont-overuse-regex---keep-your-step-definitions-simple-and-distinctive>#</a></h2><p>In cases where we have similar Given steps that we would like to match, it&rsquo;s important to avoid overusing regex to prevent step definitions from becoming too complex and harder to understand.</p><p>For example, let&rsquo;s consider the following steps:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cucumber data-lang=cucumber><span class=line><span class=cl><span class=k>Scenario:</span><span class=nf> Checkout apples in basket
</span></span></span><span class=line><span class=cl><span class=nf></span><span class=k>    Given </span><span class=nf>there are </span><span class=s>5</span><span class=nf> discounted apples in the basket
</span></span></span><span class=line><span class=cl><span class=nf>    ...
</span></span></span><span class=line><span class=cl><span class=nf>    
</span></span></span><span class=line><span class=cl><span class=nf></span><span class=k>Scenario:</span><span class=nf> Checkout medicine in basket
</span></span></span><span class=line><span class=cl><span class=nf></span><span class=k>    Given </span><span class=nf>there are </span><span class=s>2</span><span class=nf> cough medicines in the basket
</span></span></span><span class=line><span class=cl><span class=nf>    ...
</span></span></span></code></pre></div><p>Both steps involve adding items to a basket, but the number of items and the item types are different. The apples are discounted.</p><p>We can match both steps with a single step definition using the following regex:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=no>Given</span><span class=p>(</span><span class=sr>/^there are (\d*)( discounted)? (\w*) in the basket$/</span><span class=p>)</span> <span class=k>do</span> <span class=o>|</span><span class=n>num_item</span><span class=p>,</span> <span class=n>option</span><span class=p>,</span> <span class=n>item_name</span><span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=n>basket</span> <span class=o>=</span> <span class=no>Basket</span><span class=o>.</span><span class=n>new</span>
</span></span><span class=line><span class=cl>  <span class=n>basket</span><span class=o>.</span><span class=n>inventory</span> <span class=o>=</span> <span class=n>basket</span><span class=o>.</span><span class=n>insert_into_basket</span><span class=p>(</span><span class=ss>item_name</span><span class=p>:,</span> <span class=ss>num_item</span><span class=p>:,</span> <span class=ss>is_discounted</span><span class=p>:</span> <span class=n>option</span><span class=o>.</span><span class=n>present?</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>However, if the requirement states that medicines should never have discounts, it is important to separate the contexts and have two distinct step definitions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=no>Given</span><span class=p>(</span><span class=sr>/^there are (\d*) (discounted)? (\w*) in the basket$/</span><span class=p>)</span> <span class=k>do</span> <span class=o>|</span><span class=n>num_item</span><span class=p>,</span> <span class=n>option</span><span class=p>,</span> <span class=n>item_name</span><span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=n>basket</span> <span class=o>=</span> <span class=no>Basket</span><span class=o>.</span><span class=n>new</span>
</span></span><span class=line><span class=cl>  <span class=n>basket</span><span class=o>.</span><span class=n>inventory</span> <span class=o>=</span> <span class=n>basket</span><span class=o>.</span><span class=n>insert_into_basket</span><span class=p>(</span><span class=ss>item_name</span><span class=p>:,</span> <span class=ss>num_item</span><span class=p>:,</span> <span class=ss>is_discounted</span><span class=p>:</span> <span class=n>option</span><span class=o>.</span><span class=n>present?</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=no>Given</span><span class=p>(</span><span class=sr>/^there are (\d*) (\w*) medicine in the basket$/</span><span class=p>)</span> <span class=k>do</span> <span class=o>|</span><span class=n>num_medicine</span><span class=p>,</span> <span class=n>medicine_name</span><span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=n>basket</span> <span class=o>=</span> <span class=no>Basket</span><span class=o>.</span><span class=n>new</span>
</span></span><span class=line><span class=cl>  <span class=n>basket</span><span class=o>.</span><span class=n>inventory</span> <span class=o>=</span> <span class=n>basket</span><span class=o>.</span><span class=n>insert_into_basket</span><span class=p>(</span><span class=ss>item_name</span><span class=p>:</span> <span class=n>medicine_name</span><span class=p>,</span> <span class=ss>num_item</span><span class=p>:</span> <span class=n>num_medicine</span><span class=p>)</span> <span class=c1># we assume `is_discounted` has default boolean of false</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>This approach helps maintain simplicity in the code and avoids unnecessary complexity. If there are many test scenarios involving medicine in the basket, using separate step definitions will prevent repeated <code>if</code> logic and other logics in the code.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Regular expressions provide several benefits compared to Cucumber Expressions, including flexibility to include options in the steps, stricter parameter capture, and the ability to avoid using quotes unnecessarily in step parameters.</p><p>However, it is important to use regular expressions judiciously and avoid overcomplicating step definitions. Keeping step definitions simple and distinctive helps maintain code readability and understandability.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://dvla.github.io/tags/ruby/>Ruby</a></li><li><a href=https://dvla.github.io/tags/cucumber/>Cucumber</a></li><li><a href=https://dvla.github.io/tags/regex/>Regex</a></li><li><a href=https://dvla.github.io/tags/testing/>Testing</a></li><li><a href=https://dvla.github.io/tags/today-i-learned/>Today I Learned</a></li></ul><nav class=paginav><a class=prev href=https://dvla.github.io/posts/2023-06-faker-maker-chaos-update/><span class=title>« Prev</span><br><span>FakerMaker Chaos Mode Update</span></a>
<a class=next href=https://dvla.github.io/posts/2023-05-faker-maker-initialisation/><span class=title>Next »</span><br><span>FakerMaker Initialisation</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://dvla.github.io/>DVLA Engineering</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>