<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Non-Blocking Ruby Methods | DVLA Engineering</title><meta name=keywords content="Ruby,Async,Fibers,Today I Learned"><meta name=description content="Make light work of asynchronous Ruby"><meta name=author content="Nigel Brookes-Thomas"><link rel=canonical href=https://dvla.github.io/posts/2024-07-non-blocking-ruby-methods/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://dvla.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dvla.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dvla.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://dvla.github.io/favicon/apple-touch-icon.png><link rel=mask-icon href=https://dvla.github.io/favicon/favicon-16x16.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://dvla.github.io/posts/2024-07-non-blocking-ruby-methods/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-WH4N9FEEE8"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WH4N9FEEE8")}</script><meta property="og:url" content="https://dvla.github.io/posts/2024-07-non-blocking-ruby-methods/"><meta property="og:site_name" content="DVLA Engineering"><meta property="og:title" content="Non-Blocking Ruby Methods"><meta property="og:description" content="Make light work of asynchronous Ruby"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-26T00:00:00+00:00"><meta property="article:modified_time" content="2024-07-26T00:00:00+00:00"><meta property="article:tag" content="Ruby"><meta property="article:tag" content="Async"><meta property="article:tag" content="Fibers"><meta property="article:tag" content="Today I Learned"><meta property="og:image" content="https://dvla.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dvla.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Non-Blocking Ruby Methods"><meta name=twitter:description content="Make light work of asynchronous Ruby"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dvla.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Non-Blocking Ruby Methods","item":"https://dvla.github.io/posts/2024-07-non-blocking-ruby-methods/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Non-Blocking Ruby Methods","name":"Non-Blocking Ruby Methods","description":"Make light work of asynchronous Ruby","keywords":["Ruby","Async","Fibers","Today I Learned"],"articleBody":"There are lot of options for concurrency in Ruby, from spawning child processes to using threads, ractors and Async. Each have their merits and drawbacks, but one of the simplest and most effective ways to run code concurrently is to use Fibers.\nIn my use-case, I want to do some work and, in the background, perform some network requests. Network I/O is blocking, so I want to make sure I’m doing productive work on the main thread while I wait for the network requests to complete.\nFibers Fibers are lightweight but fairly low-level primitives. They allow you to pause and resume execution at will. Whenever they pause, they yield control back to the caller, which can then resume the Fiber at a later time. This is great for enumerators which can process a loop and return the computed value to the caller.\nIn my case I want to yield control whenever an operation blocks. Fortunately, Ruby has introduced a Fiber scheduler interface and the async gem provides a high-level API which handles the gnarly details of just this use-case.\nExample With this in my Gemfile:\ngem \"async\", \"~\u003e 2.14\" Here’s a simple example of how to use the async fiber scheduler to run a non-blocking method:\nmodule API scheduler = Async::Scheduler.new Fiber.set_scheduler(scheduler) def self.perform(iteration) Fiber.schedule do puts \"Making request...#{iteration}\" req = HTTParty.get('http://localhost:9292') puts \" \\tDone with request #{iteration}: #{req.body[0..30]}\" end end end When this module loads, Fiber.set_scheduler(Async::Scheduler.new) installs a Async::Scheduler as the fiber scheduler on the current thread. In my case, this is the main thread.\nA call to API.perfom will create the fiber, register it with the scheduler and start running it. The networking request via HTTParty.get blocks – this causes the fiber to yield control back to the scheduler. The scheduler can then run other fibers, including the main thread, until the network request completes.\nLet’s put it to use:\nrequire 'async/scheduler' require 'httparty' require_relative 'api' puts 'Starting up...' 5.times do |i| API.perform(i) end puts 'Finished!' The code will schedule 5 fibers to run concurrently, each making a network request. The main thread will continue to run and print ‘Finished!’ before the network requests complete.\nTo try this out, I have a super simple Roda web server running on http://localhost:9292:\nrequire 'roda' class App \u003c Roda route do |r| # GET / request r.root do sleep(rand(0.3..1)) # Simulate some work 'Hello world!' end end end run App.freeze.app When I run the the client code, I see the following output:\nStarting up... Making request...0 Making request...1 Making request...2 Making request...3 Making request...4 Finished! Done with request 3: Hello world! Done with request 4: Hello world! Done with request 1: Hello world! Done with request 2: Hello world! Done with request 0: Hello world! The main thread continues to run while the network requests are in progress. When the requests complete, the fibers are resumed and the results are printed to the console. All the fibers run to completion before the program exits. Nice.\nBonus section Roda is pretty speedy framework but I’m running here with the basic Rackup server. I can queue about 500 Fibers before saturating the server and it starts rejecting connections. The Falcon web server is written by Samuel Williams, the same author as the Async gem, and is designed to work well with Async. It’s a great choice for running high-performance Ruby web servers, so let’s try that.\nTo use Falcon, add it to your server’s Gemfile:\ngem \"falcon\", \"~\u003e 0.47.7\" Because I want to start it without TLS, I run it like this:\nbundle exec falcon serve -b http://localhost:9292 Now I can run the client code and queue up as many fibers as I like. Falcon will handle them all without breaking a sweat. I can hit 2,000 connections and exhaust my client machine’s file handles before Falcon starts to struggle. That’s a lot of concurrent requests!\nTiming the execution tells me this:\n$ time bundle exec ruby main.rb bundle exec ruby main.rb 0.64s user 0.25s system 45% cpu 1.958 total Two thousand requests in under 2 seconds. Not bad for a single-threaded Ruby program!\n","wordCount":"681","inLanguage":"en","image":"https://dvla.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-07-26T00:00:00Z","dateModified":"2024-07-26T00:00:00Z","author":{"@type":"Person","name":"Nigel Brookes-Thomas"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dvla.github.io/posts/2024-07-non-blocking-ruby-methods/"},"publisher":{"@type":"Organization","name":"DVLA Engineering","logo":{"@type":"ImageObject","url":"https://dvla.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dvla.github.io/ accesskey=h title="DVLA Engineering (Alt + H)"><img src=https://dvla.github.io/favicon/apple-touch-icon.png alt aria-label=logo height=49>DVLA Engineering</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://dvla.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://dvla.github.io/open-source/ title=Open-source><span>Open-source</span></a></li><li><a href=https://github.com/dvla/ title=Github><span>Github</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://www.civil-service-careers.gov.uk/departments/working-for-the-driver-and-vehicle-licensing-agency/ title=Careers><span>Careers</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dvla.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://dvla.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Non-Blocking Ruby Methods</h1><div class=post-description>Make light work of asynchronous Ruby</div><div class=post-meta><span title='2024-07-26 00:00:00 +0000 UTC'>July 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;681 words&nbsp;·&nbsp;Nigel Brookes-Thomas</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#fibers>Fibers</a></li><li><a href=#example>Example</a></li><li><a href=#bonus-section>Bonus section</a></li></ul></nav></div></details></div><div class=post-content><p>There are lot of options for concurrency in Ruby, from spawning child processes to using threads, ractors and Async. Each have their merits and drawbacks, but one of the simplest and most effective ways to run code concurrently is to use Fibers.</p><p>In my use-case, I want to do some work and, in the background, perform some network requests. Network I/O is blocking, so I want to make sure I&rsquo;m doing productive work on the main thread while I wait for the network requests to complete.</p><h2 id=fibers>Fibers<a hidden class=anchor aria-hidden=true href=#fibers>#</a></h2><p>Fibers are lightweight but fairly low-level primitives. They allow you to pause and resume execution at will. Whenever they pause, they yield control back to the caller, which can then resume the Fiber at a later time. This is great for enumerators which can process a loop and return the computed value to the caller.</p><p>In my case I want to yield control whenever an operation blocks. Fortunately, Ruby has introduced a Fiber scheduler interface and the <code>async</code> gem provides a high-level API which handles the gnarly details of just this use-case.</p><h2 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h2><p>With this in my Gemfile:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=n>gem</span> <span class=s2>&#34;async&#34;</span><span class=p>,</span> <span class=s2>&#34;~&gt; 2.14&#34;</span>
</span></span></code></pre></div><p>Here&rsquo;s a simple example of how to use the <code>async</code> fiber scheduler to run a non-blocking method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=k>module</span> <span class=nn>API</span>
</span></span><span class=line><span class=cl>  <span class=n>scheduler</span> <span class=o>=</span> <span class=no>Async</span><span class=o>::</span><span class=no>Scheduler</span><span class=o>.</span><span class=n>new</span>
</span></span><span class=line><span class=cl>  <span class=no>Fiber</span><span class=o>.</span><span class=n>set_scheduler</span><span class=p>(</span><span class=n>scheduler</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nc>self</span><span class=o>.</span><span class=nf>perform</span><span class=p>(</span><span class=n>iteration</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=no>Fiber</span><span class=o>.</span><span class=n>schedule</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>      <span class=nb>puts</span> <span class=s2>&#34;Making request...</span><span class=si>#{</span><span class=n>iteration</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>      <span class=n>req</span> <span class=o>=</span> <span class=no>HTTParty</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;http://localhost:9292&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nb>puts</span> <span class=s2>&#34; </span><span class=se>\t</span><span class=s2>Done with request </span><span class=si>#{</span><span class=n>iteration</span><span class=si>}</span><span class=s2>: </span><span class=si>#{</span><span class=n>req</span><span class=o>.</span><span class=n>body</span><span class=o>[</span><span class=mi>0</span><span class=o>..</span><span class=mi>30</span><span class=o>]</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>When this module loads, <code>Fiber.set_scheduler(Async::Scheduler.new)</code> installs a <code>Async::Scheduler</code> as the fiber scheduler on the current thread. In my case, this is the main thread.</p><p>A call to <code>API.perfom</code> will create the fiber, register it with the scheduler and start running it. The networking request via <code>HTTParty.get</code> blocks &ndash; this causes the fiber to yield control back to the scheduler. The scheduler can then run other fibers, including the main thread, until the network request completes.</p><p>Let&rsquo;s put it to use:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=nb>require</span> <span class=s1>&#39;async/scheduler&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>require</span> <span class=s1>&#39;httparty&#39;</span>
</span></span><span class=line><span class=cl><span class=n>require_relative</span> <span class=s1>&#39;api&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>puts</span> <span class=s1>&#39;Starting up...&#39;</span>
</span></span><span class=line><span class=cl><span class=mi>5</span><span class=o>.</span><span class=n>times</span> <span class=k>do</span> <span class=o>|</span><span class=n>i</span><span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=no>API</span><span class=o>.</span><span class=n>perform</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl><span class=nb>puts</span> <span class=s1>&#39;Finished!&#39;</span>
</span></span></code></pre></div><p>The code will schedule 5 fibers to run concurrently, each making a network request. The main thread will continue to run and print &lsquo;Finished!&rsquo; before the network requests complete.</p><p>To try this out, I have a super simple Roda web server running on <code>http://localhost:9292</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=nb>require</span> <span class=s1>&#39;roda&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>App</span> <span class=o>&lt;</span> <span class=no>Roda</span>
</span></span><span class=line><span class=cl>  <span class=n>route</span> <span class=k>do</span> <span class=o>|</span><span class=n>r</span><span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=c1># GET / request</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=o>.</span><span class=n>root</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>      <span class=nb>sleep</span><span class=p>(</span><span class=nb>rand</span><span class=p>(</span><span class=mi>0</span><span class=o>.</span><span class=mi>3</span><span class=o>..</span><span class=mi>1</span><span class=p>))</span> <span class=c1># Simulate some work</span>
</span></span><span class=line><span class=cl>      <span class=s1>&#39;Hello world!&#39;</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>run</span> <span class=no>App</span><span class=o>.</span><span class=n>freeze</span><span class=o>.</span><span class=n>app</span>
</span></span></code></pre></div><p>When I run the the client code, I see the following output:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Starting up...
</span></span><span class=line><span class=cl>Making request...0
</span></span><span class=line><span class=cl>Making request...1
</span></span><span class=line><span class=cl>Making request...2
</span></span><span class=line><span class=cl>Making request...3
</span></span><span class=line><span class=cl>Making request...4
</span></span><span class=line><span class=cl>Finished!
</span></span><span class=line><span class=cl> 	Done with request 3: Hello world!
</span></span><span class=line><span class=cl> 	Done with request 4: Hello world!
</span></span><span class=line><span class=cl> 	Done with request 1: Hello world!
</span></span><span class=line><span class=cl> 	Done with request 2: Hello world!
</span></span><span class=line><span class=cl> 	Done with request 0: Hello world!
</span></span></code></pre></div><p>The main thread continues to run while the network requests are in progress. When the requests complete, the fibers are resumed and the results are printed to the console. All the fibers run to completion before the program exits. Nice.</p><h2 id=bonus-section>Bonus section<a hidden class=anchor aria-hidden=true href=#bonus-section>#</a></h2><p>Roda is pretty speedy framework but I&rsquo;m running here with the basic Rackup server. I can queue about 500 Fibers before saturating the server and it starts rejecting connections. The Falcon web server is written by Samuel Williams, the same author as the Async gem, and is designed to work well with Async. It&rsquo;s a great choice for running high-performance Ruby web servers, so let&rsquo;s try that.</p><p>To use Falcon, add it to your server&rsquo;s Gemfile:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=n>gem</span> <span class=s2>&#34;falcon&#34;</span><span class=p>,</span> <span class=s2>&#34;~&gt; 0.47.7&#34;</span>
</span></span></code></pre></div><p>Because I want to start it without TLS, I run it like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>bundle <span class=nb>exec</span> falcon serve -b http://localhost:9292
</span></span></code></pre></div><p>Now I can run the client code and queue up as many fibers as I like. Falcon will handle them all without breaking a sweat. I can hit 2,000 connections and exhaust my client machine&rsquo;s file handles before Falcon starts to struggle. That&rsquo;s a lot of concurrent requests!</p><p>Timing the execution tells me this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ <span class=nb>time</span> bundle <span class=nb>exec</span> ruby main.rb
</span></span><span class=line><span class=cl>bundle <span class=nb>exec</span> ruby main.rb  0.64s user 0.25s system 45% cpu 1.958 total
</span></span></code></pre></div><p>Two thousand requests in under 2 seconds. Not bad for a single-threaded Ruby program!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://dvla.github.io/tags/ruby/>Ruby</a></li><li><a href=https://dvla.github.io/tags/async/>Async</a></li><li><a href=https://dvla.github.io/tags/fibers/>Fibers</a></li><li><a href=https://dvla.github.io/tags/today-i-learned/>Today I Learned</a></li></ul><nav class=paginav><a class=prev href=https://dvla.github.io/posts/2024-07-ruby-gsub-hashes/><span class=title>« Prev</span><br><span>TiL: Doing multiple replacements with gsub in Ruby</span>
</a><a class=next href=https://dvla.github.io/posts/2024-07-adding-numerous-tags-to-paralleltests-in-cucumber-elegantly/><span class=title>Next »</span><br><span>TiL: Adding numerous tags to ParallelTests in cucumber elegantly</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://dvla.github.io/>DVLA Engineering</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>