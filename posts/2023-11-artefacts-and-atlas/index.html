<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Artefacts in tests and managing them with Atlas | DVLA Engineering</title>
<meta name=keywords content="Ruby,Testing,Cucumber,Gem"><meta name=description content="A look at our concept of artefacts in functional test packs and how we manage them using Atlas."><meta name=author content="Nigel Brookes-Thomas & George Bell"><link rel=canonical href=https://dvla.github.io/posts/2023-11-artefacts-and-atlas/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://dvla.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dvla.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dvla.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://dvla.github.io/favicon/apple-touch-icon.png><link rel=mask-icon href=https://dvla.github.io/favicon/favicon-16x16.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-WH4N9FEEE8"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WH4N9FEEE8",{anonymize_ip:!1})}</script><meta property="og:title" content="Artefacts in tests and managing them with Atlas"><meta property="og:description" content="A look at our concept of artefacts in functional test packs and how we manage them using Atlas."><meta property="og:type" content="article"><meta property="og:url" content="https://dvla.github.io/posts/2023-11-artefacts-and-atlas/"><meta property="og:image" content="https://dvla.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-14T00:00:00+00:00"><meta property="article:modified_time" content="2023-11-14T00:00:00+00:00"><meta property="og:site_name" content="DVLA Engineering"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dvla.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Artefacts in tests and managing them with Atlas"><meta name=twitter:description content="A look at our concept of artefacts in functional test packs and how we manage them using Atlas."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dvla.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Artefacts in tests and managing them with Atlas","item":"https://dvla.github.io/posts/2023-11-artefacts-and-atlas/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Artefacts in tests and managing them with Atlas","name":"Artefacts in tests and managing them with Atlas","description":"A look at our concept of artefacts in functional test packs and how we manage them using Atlas.","keywords":["Ruby","Testing","Cucumber","Gem"],"articleBody":"We’ve recently publicly released a Gem called dvla-atlas1 and today we are going to take you through a bit of history surrounding testing at the DVLA that led to use developing Atlas, along with a dive into some of the code that makes it tick. Atlas is designed to make the managing of properties in functional tests easier while also ensuring that each test is run in isolation and without any cross-pollination of test data. But first, lets take a look at what we mean by artefacts and we used them in tests we’d written in Cucumber.\nArtefacts We follow Acceptance Test Driven Design (ATDD) wherever we can and use Cucumber and Gherkin as the backbone for expressing customer wants in a specification we can use to see if we’ve actually met that want. Oh, and we love ruby.\nGiven I am using Cucumber When I write a specification Then I will have a series of steps With the specification above, we have three steps with a clear arrange-act-assert order which collectively forms one scenario – one test. On the programmatic side, these are modelled as three separate methods and to pass information from one to the next we use instance variables.\nSince we’re using a dynamic language we can pop these into existance at will. This is fine but has two problems:\nUsing very generic variable names Typos A great advantage in having a rich and beautifully constructed automation pack is that often you can create new test scenarios just be stitching together the steps you already have. This becomes a real problem with generic variable names: calling everything @result will not give you great confidence that you really are asserting against what you expect.\nThe other problem is typos. The ruby parser performs some variable hoisting: for instance variables this happens on reference. This means that all instance variables which are referenced but not assigned a value will be nil. There will be no NameError raised for undefined instance variables. This means that tests like…\nexpect(@badly_spelled_instance_variable).to be_nil …will always succeed if we’ve misspelled our instance variable’s name.\nTo mitigate this problem, we’ve adopted a stategy of declaring upfront those bits of state we want to keep a hold of and pass from one step to another. We built a Struct in which we could declare the fields we wanted and a helper method we called artefacts. Declaring this upgront meant we thought quite hard about what to name these things and more meaning emerged. The Struct helped us catch misspelt fields by throwing exceptions at runtime if we used a non-existent field.\nOur needs grew though. We’d bolt FakerMaker factory built objects in here with default values. Struct wasn’t cutting it for us so we switched to full fat classes with neat control over object construction and defaults. This was transparent to us because we always used our lovely convenice method…\ndef artefacts @artefacts ||= Artefacts.new end # ... artefacts.my_field Which breaks down as soon as you start grouping functionality into modules or classes because, if you’re not very careful, you can end up with two (or more) distinct instances of @artefacts with different scopes. Singleton-patterm instances also don’t fit our needs because we need to throw away all of the artefacts after each scenario and can’t have them leaking state between each other.\nSo this is problem we want to solve:\na place to define the state we want to share up front to have the runtime throw an error if some undefined state is referenced we want to throw away the state after each scenario we want it to be super easy to use work transparently with bare methods and those in modules and classes So we wrote Altas. It’s a small library, but a great deal of thought has gone into it and make it hit each of those needs.\nAtlas With Atlas, we hope to formalise what we were doing with artefacts without distrupting the way we like to write tests. Our goal was to leverage some functionality built into Cucumber called World2 while also having something nice and easy to pick up and use.\nDefining properties Within a test pack, it is not uncommon for multiple scenarios to require property with a common name, such as email_address. While with tools like faker-maker it’s nice and simple to make sure each scenario has a different, but realistic-looking, value. We want to make sure that each step that references that property is consistent in what it is called. Having half your tests refer to email_address and the other half to emailAddress is a fantastic way to introduce confusion where it isn’t needed. That’s where World comes in handy.\nWorld allows you to define the context within which test steps are executed. You can provide it with a block of code, traditionally in your env.rb when setting up the tests, that will be executed prior to each test, with the value that block returns being the context in which the tests are run. For example, suppose we write the following in our environment file:\nclass Example attr_reader :value def initialize(base_value) @value = base_value end def add_to_value(value_to_add) @value += value_to_add end end World do Example.new(2) end With the above set up, you’d be able to access value and call add_to_value in any test step, with that block being called again at the beginning of each new scenario to generate the context that it will be run in. Therefore, each test will start with a value of 2. It’s on top of this Cucumber functionality that we built Atlas:\nWorld do world = DVLA::Atlas.base_world world.artefacts.define_fields('email_address') world end DVLA::Atlas.base_world returns an object that contains an empty set of artefacts. Upon that we can call define_fields, which will allow us to create as many properties as we need. These are then made accessible to all test steps, as they are now part of the context they are being run in, ensuring that we have consistent naming throughout our test pack with a singular source of truth for what those names are.\nDefault values Once you’ve got property creation on the artefacts up and running, the next obvious step is default values. There are times where might want a property to start out a specific value. In that case, you can pass in that value as the keyword against the property name, as seen below:\nWorld do world = DVLA::Atlas.base_world world.artefacts.define_fields(url: 'www.example.com') world end That gives all test steps access to the property url, which they can alter as much as they like to do whatever it is they need to do, with each new scenario getting a newly initalized world that is back to the default value\nScoping A number of our tests rely on code being able to access artefacts from not only within the scope of the test steps but within various other classes and modules. There are times where it makes sense to pass these values around through the various method calls, but likewise there are times were that proved to not be practical. Thus, by adding DVLA::Atlas.make_artefacts_global(world.artefacts) into the World block once all the fields on artefacts have been set up, we can make them globally accessible. This works within Atlas by using a bit of metaprogramming to define a getter on Object that points to the artefacts, as seen here:\ndef self.make_artefacts_global(artefacts) DVLA::Atlas::Holder.instance.artefacts = artefacts Object.send(:define_method, :artefacts) { DVLA::Atlas::Holder.instance.artefacts } end Trackable history Finally, this is something we’ve had a few people had implemented independently and Atlas felt like the perfect place to formalise this functionality. There are times where a test might want to validate a sequence, such as the order pages have been visited in a journey through a website. Historically, people were creating various data structures to store these details, however in Atlas all properties that are initialised also come with a history field that stores an array of all previous values that that property has held. Take the following example:\nWorld do world = DVLA::Atlas.base_world world.artefacts.define_fields(journey_status: :started) world end ... Given 'the customer hits the submit button' do artefacts.journey_status = fetch_journey_status # Should now be submitted end ... When 'the query has been dealt with' do artefacts.journey_status = fetch_journey_status # Should now be completed end Then 'the journey has hit all the correct statuses' do expect(artefacts.journey_status).to eq(:completed) expect(artefacts.journey_status_history).to eq([:started, :submitted]) end In the above example, we can not only assert that the journey_status ends up at completed but that it took the right path to get there. If a code change went in that accidentally pushed the journey into cancelled instead of submitted, we’d be able to catch that even if the system still ended up in the correct place. Again, through the use of metaprogramming, we were able to implement this in quite a lightweight fashion, as seen in the below code extract from Atlas:\ninstance_variable_set(\"@#{name}_history\", []) define_singleton_method :\"#{name}_history\" do instance_variable_get(\"@#{name}_history\") end define_singleton_method :\"#{name}=\" do |arg| current_value = send(:\"#{name}\") send(:\"#{name}_history\").push(current_value) unless send(:\"#{name}_history\").empty? \u0026\u0026 current_value.nil? instance_variable_set(\"@#{name}\", arg) end As you can see, we create the history as an empty array and define a getter for it. Then, as part of the definition of the setter for the actual property, we have line that pushes the value that is being overwritten into the history. This means that the setter can’t be called without also updating the relevant history and ensures we are can access whatever previous values we require with no additional setup required when actually writing the tests.\nAs you’ll see, we’ve named it that because it supports the World ↩︎\nIf you haven’t come across World in Cucumber before, it’s a way of influencing the context within with a test scenario is run. You don’t need to worry about the specifics for this post, as we’ll explain them as they become relevant, but if you are interested in the inner workings you can find some tests that document the common uses for it in the Ruby implementation of Cucumber ↩︎\n","wordCount":"1658","inLanguage":"en","datePublished":"2023-11-14T00:00:00Z","dateModified":"2023-11-14T00:00:00Z","author":{"@type":"Person","name":"Nigel Brookes-Thomas \u0026 George Bell"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dvla.github.io/posts/2023-11-artefacts-and-atlas/"},"publisher":{"@type":"Organization","name":"DVLA Engineering","logo":{"@type":"ImageObject","url":"https://dvla.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dvla.github.io/ accesskey=h title="DVLA Engineering (Alt + H)"><img src=https://dvla.github.io/favicon/apple-touch-icon.png alt aria-label=logo height=49>DVLA Engineering</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://dvla.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://dvla.github.io/open-source/ title=Open-source><span>Open-source</span></a></li><li><a href=https://github.com/dvla/ title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://www.civil-service-careers.gov.uk/departments/working-for-the-driver-and-vehicle-licensing-agency/ title=Careers><span>Careers</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dvla.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://dvla.github.io/posts/>Posts</a></div><h1 class=post-title>Artefacts in tests and managing them with Atlas</h1><div class=post-description>A look at our concept of artefacts in functional test packs and how we manage them using Atlas.</div><div class=post-meta>&lt;span title='2023-11-14 00:00:00 +0000 UTC'>November 14, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;8 min&amp;nbsp;·&amp;nbsp;1658 words&amp;nbsp;·&amp;nbsp;Nigel Brookes-Thomas &amp;amp; George Bell</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#artefacts>Artefacts</a></li><li><a href=#atlas>Atlas</a><ul><li><a href=#defining-properties>Defining properties</a></li><li><a href=#default-values>Default values</a></li><li><a href=#scoping>Scoping</a></li><li><a href=#trackable-history>Trackable history</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>We&rsquo;ve recently publicly released a Gem called <a href=https://github.com/dvla/atlas>dvla-atlas</a><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> and today we are going to take you through a bit of history surrounding testing at the DVLA that led to use developing Atlas, along with a dive into some of the code that makes it tick. Atlas is designed to make the managing of properties in functional tests easier while also ensuring that each test is run in isolation and without any cross-pollination of test data. But first, lets take a look at what we mean by artefacts and we used them in tests we&rsquo;d written in <a href=https://cucumber.io/>Cucumber</a>.</p><h2 id=artefacts>Artefacts<a hidden class=anchor aria-hidden=true href=#artefacts>#</a></h2><p>We follow Acceptance Test Driven Design (ATDD) wherever we can and use Cucumber and Gherkin as the backbone for expressing customer wants in a specification we can use to see if we&rsquo;ve actually met that want. Oh, and we love ruby.</p><pre tabindex=0><code>Given I am using Cucumber
When I write a specification
Then I will have a series of steps
</code></pre><p>With the specification above, we have three steps with a clear arrange-act-assert order which collectively forms one scenario &ndash; one test. On the programmatic side, these are modelled as three separate methods and to pass information from one to the next we use instance variables.</p><p>Since we&rsquo;re using a dynamic language we can pop these into existance at will. This is fine but has two problems:</p><ol><li>Using very generic variable names</li><li>Typos</li></ol><p>A great advantage in having a rich and beautifully constructed automation pack is that often you can create new test scenarios just be stitching together the steps you already have. This becomes a real problem with generic variable names: calling everything <code>@result</code> will not give you great confidence that you really are asserting against what you expect.</p><p>The other problem is typos. The ruby parser performs some variable hoisting: for instance variables this happens on reference. This means that all instance variables which are referenced but not assigned a value will be <code>nil</code>. There will be no <code>NameError</code> raised for undefined instance variables. This means that tests like&mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=n>expect</span><span class=p>(</span><span class=vi>@badly_spelled_instance_variable</span><span class=p>)</span><span class=o>.</span><span class=n>to</span> <span class=n>be_nil</span>
</span></span></code></pre></div><p>&mldr;will always succeed if we&rsquo;ve misspelled our instance variable&rsquo;s name.</p><p>To mitigate this problem, we&rsquo;ve adopted a stategy of declaring upfront those bits of state we want to keep a hold of and pass from one step to another. We built a <code>Struct</code> in which we could declare the fields we wanted and a helper method we called <code>artefacts</code>. Declaring this upgront meant we thought quite hard about what to name these things and more meaning emerged. The <code>Struct</code> helped us catch misspelt fields by throwing exceptions at runtime if we used a non-existent field.</p><p>Our needs grew though. We&rsquo;d bolt <a href=https://billyruffian.github.io/faker_maker/>FakerMaker</a> factory built objects in here with default values. <code>Struct</code> wasn&rsquo;t cutting it for us so we switched to full fat classes with neat control over object construction and defaults. This was transparent to us because we always used our lovely convenice method&mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=k>def</span> <span class=nf>artefacts</span>
</span></span><span class=line><span class=cl>  <span class=vi>@artefacts</span> <span class=o>||=</span> <span class=no>Artefacts</span><span class=o>.</span><span class=n>new</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>artefacts</span><span class=o>.</span><span class=n>my_field</span>
</span></span></code></pre></div><p>Which breaks down as soon as you start grouping functionality into modules or classes because, if you&rsquo;re not very careful, you can end up with two (or more) distinct instances of <code>@artefacts</code> with different scopes. Singleton-patterm instances also don&rsquo;t fit our needs because we need to throw away all of the artefacts after each <em>scenario</em> and can&rsquo;t have them leaking state between each other.</p><p>So this is problem we want to solve:</p><ol><li>a place to define the state we want to share up front</li><li>to have the runtime throw an error if some undefined state is referenced</li><li>we want to throw away the state after each scenario</li><li>we want it to be super easy to use</li><li>work transparently with bare methods and those in modules and classes</li></ol><p>So we wrote Altas. It&rsquo;s a small library, but a great deal of thought has gone into it and make it hit each of those needs.</p><h2 id=atlas>Atlas<a hidden class=anchor aria-hidden=true href=#atlas>#</a></h2><p>With Atlas, we hope to formalise what we were doing with artefacts without distrupting the way we like to write tests. Our goal was to leverage some functionality built into Cucumber called <code>World</code><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> while also having something nice and easy to pick up and use.</p><h3 id=defining-properties>Defining properties<a hidden class=anchor aria-hidden=true href=#defining-properties>#</a></h3><p>Within a test pack, it is not uncommon for multiple scenarios to require property with a common name, such as <code>email_address</code>. While with tools like <a href=https://github.com/BillyRuffian/faker_maker>faker-maker</a> it&rsquo;s nice and simple to make sure each scenario has a different, but realistic-looking, value. We want to make sure that each step that references that property is consistent in what it is called. Having half your tests refer to <code>email_address</code> and the other half to <code>emailAddress</code> is a fantastic way to introduce confusion where it isn&rsquo;t needed. That&rsquo;s where <code>World</code> comes in handy.</p><p><code>World</code> allows you to define the context within which test steps are executed. You can provide it with a block of code, traditionally in your <code>env.rb</code> when setting up the tests, that will be executed prior to each test, with the value that block returns being the context in which the tests are run. For example, suppose we write the following in our environment file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=k>class</span> <span class=nc>Example</span>
</span></span><span class=line><span class=cl>    <span class=kp>attr_reader</span> <span class=ss>:value</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>initialize</span><span class=p>(</span><span class=n>base_value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=vi>@value</span> <span class=o>=</span> <span class=n>base_value</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>add_to_value</span><span class=p>(</span><span class=n>value_to_add</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=vi>@value</span> <span class=o>+=</span> <span class=n>value_to_add</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=no>World</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=no>Example</span><span class=o>.</span><span class=n>new</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>With the above set up, you&rsquo;d be able to access <code>value</code> and call <code>add_to_value</code> in any test step, with that block being called again at the beginning of each new scenario to generate the context that it will be run in. Therefore, each test will start with a <code>value</code> of 2. It&rsquo;s on top of this Cucumber functionality that we built Atlas:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=no>World</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=n>world</span> <span class=o>=</span> <span class=no>DVLA</span><span class=o>::</span><span class=no>Atlas</span><span class=o>.</span><span class=n>base_world</span>
</span></span><span class=line><span class=cl>    <span class=n>world</span><span class=o>.</span><span class=n>artefacts</span><span class=o>.</span><span class=n>define_fields</span><span class=p>(</span><span class=s1>&#39;email_address&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>world</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p><code>DVLA::Atlas.base_world</code> returns an object that contains an empty set of artefacts. Upon that we can call <code>define_fields</code>, which will allow us to create as many properties as we need. These are then made accessible to all test steps, as they are now part of the context they are being run in, ensuring that we have consistent naming throughout our test pack with a singular source of truth for what those names are.</p><h3 id=default-values>Default values<a hidden class=anchor aria-hidden=true href=#default-values>#</a></h3><p>Once you&rsquo;ve got property creation on the artefacts up and running, the next obvious step is default values. There are times where might want a property to start out a specific value. In that case, you can pass in that value as the keyword against the property name, as seen below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=no>World</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=n>world</span> <span class=o>=</span> <span class=no>DVLA</span><span class=o>::</span><span class=no>Atlas</span><span class=o>.</span><span class=n>base_world</span>
</span></span><span class=line><span class=cl>    <span class=n>world</span><span class=o>.</span><span class=n>artefacts</span><span class=o>.</span><span class=n>define_fields</span><span class=p>(</span><span class=ss>url</span><span class=p>:</span> <span class=s1>&#39;www.example.com&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>world</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>That gives all test steps access to the property <code>url</code>, which they can alter as much as they like to do whatever it is they need to do, with each new scenario getting a newly initalized world that is back to the default value</p><h3 id=scoping>Scoping<a hidden class=anchor aria-hidden=true href=#scoping>#</a></h3><p>A number of our tests rely on code being able to access artefacts from not only within the scope of the test steps but within various other classes and modules. There are times where it makes sense to pass these values around through the various method calls, but likewise there are times were that proved to not be practical. Thus, by adding <code>DVLA::Atlas.make_artefacts_global(world.artefacts)</code> into the <code>World</code> block once all the fields on artefacts have been set up, we can make them globally accessible. This works within Atlas by using a bit of metaprogramming to define a getter on <code>Object</code> that points to the artefacts, as seen here:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=k>def</span> <span class=nc>self</span><span class=o>.</span><span class=nf>make_artefacts_global</span><span class=p>(</span><span class=n>artefacts</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=no>DVLA</span><span class=o>::</span><span class=no>Atlas</span><span class=o>::</span><span class=no>Holder</span><span class=o>.</span><span class=n>instance</span><span class=o>.</span><span class=n>artefacts</span> <span class=o>=</span> <span class=n>artefacts</span>
</span></span><span class=line><span class=cl>    <span class=no>Object</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=ss>:define_method</span><span class=p>,</span> <span class=ss>:artefacts</span><span class=p>)</span> <span class=p>{</span> <span class=no>DVLA</span><span class=o>::</span><span class=no>Atlas</span><span class=o>::</span><span class=no>Holder</span><span class=o>.</span><span class=n>instance</span><span class=o>.</span><span class=n>artefacts</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><h3 id=trackable-history>Trackable history<a hidden class=anchor aria-hidden=true href=#trackable-history>#</a></h3><p>Finally, this is something we&rsquo;ve had a few people had implemented independently and Atlas felt like the perfect place to formalise this functionality. There are times where a test might want to validate a sequence, such as the order pages have been visited in a journey through a website. Historically, people were creating various data structures to store these details, however in Atlas all properties that are initialised also come with a history field that stores an array of all previous values that that property has held. Take the following example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=no>World</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=n>world</span> <span class=o>=</span> <span class=no>DVLA</span><span class=o>::</span><span class=no>Atlas</span><span class=o>.</span><span class=n>base_world</span>
</span></span><span class=line><span class=cl>  <span class=n>world</span><span class=o>.</span><span class=n>artefacts</span><span class=o>.</span><span class=n>define_fields</span><span class=p>(</span><span class=ss>journey_status</span><span class=p>:</span> <span class=ss>:started</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>world</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=no>Given</span> <span class=s1>&#39;the customer hits the submit button&#39;</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=n>artefacts</span><span class=o>.</span><span class=n>journey_status</span> <span class=o>=</span> <span class=n>fetch_journey_status</span> <span class=c1># Should now be submitted </span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=no>When</span> <span class=s1>&#39;the query has been dealt with&#39;</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=n>artefacts</span><span class=o>.</span><span class=n>journey_status</span> <span class=o>=</span> <span class=n>fetch_journey_status</span> <span class=c1># Should now be completed</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=no>Then</span> <span class=s1>&#39;the journey has hit all the correct statuses&#39;</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=n>expect</span><span class=p>(</span><span class=n>artefacts</span><span class=o>.</span><span class=n>journey_status</span><span class=p>)</span><span class=o>.</span><span class=n>to</span> <span class=n>eq</span><span class=p>(</span><span class=ss>:completed</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>expect</span><span class=p>(</span><span class=n>artefacts</span><span class=o>.</span><span class=n>journey_status_history</span><span class=p>)</span><span class=o>.</span><span class=n>to</span> <span class=n>eq</span><span class=p>(</span><span class=o>[</span><span class=ss>:started</span><span class=p>,</span> <span class=ss>:submitted</span><span class=o>]</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>In the above example, we can not only assert that the <code>journey_status</code> ends up at <code>completed</code> but that it took the right path to get there. If a code change went in that accidentally pushed the journey into <code>cancelled</code> instead of <code>submitted</code>, we&rsquo;d be able to catch that even if the system still ended up in the correct place. Again, through the use of metaprogramming, we were able to implement this in quite a lightweight fashion, as seen in the below code extract from Atlas:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=nb>instance_variable_set</span><span class=p>(</span><span class=s2>&#34;@</span><span class=si>#{</span><span class=nb>name</span><span class=si>}</span><span class=s2>_history&#34;</span><span class=p>,</span> <span class=o>[]</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>define_singleton_method</span> <span class=ss>:&#34;</span><span class=si>#{</span><span class=nb>name</span><span class=si>}</span><span class=ss>_history&#34;</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nb>instance_variable_get</span><span class=p>(</span><span class=s2>&#34;@</span><span class=si>#{</span><span class=nb>name</span><span class=si>}</span><span class=s2>_history&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>define_singleton_method</span> <span class=ss>:&#34;</span><span class=si>#{</span><span class=nb>name</span><span class=si>}</span><span class=ss>=&#34;</span> <span class=k>do</span> <span class=o>|</span><span class=n>arg</span><span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=n>current_value</span> <span class=o>=</span> <span class=nb>send</span><span class=p>(</span><span class=ss>:&#34;</span><span class=si>#{</span><span class=nb>name</span><span class=si>}</span><span class=ss>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>send</span><span class=p>(</span><span class=ss>:&#34;</span><span class=si>#{</span><span class=nb>name</span><span class=si>}</span><span class=ss>_history&#34;</span><span class=p>)</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=n>current_value</span><span class=p>)</span> <span class=k>unless</span> <span class=nb>send</span><span class=p>(</span><span class=ss>:&#34;</span><span class=si>#{</span><span class=nb>name</span><span class=si>}</span><span class=ss>_history&#34;</span><span class=p>)</span><span class=o>.</span><span class=n>empty?</span> <span class=o>&amp;&amp;</span> <span class=n>current_value</span><span class=o>.</span><span class=n>nil?</span>
</span></span><span class=line><span class=cl>    <span class=nb>instance_variable_set</span><span class=p>(</span><span class=s2>&#34;@</span><span class=si>#{</span><span class=nb>name</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>As you can see, we create the history as an empty array and define a getter for it. Then, as part of the definition of the setter for the actual property, we have line that pushes the value that is being overwritten into the history. This means that the setter can&rsquo;t be called without also updating the relevant history and ensures we are can access whatever previous values we require with no additional setup required when actually writing the tests.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>As you&rsquo;ll see, we&rsquo;ve named it that because it supports the <code>World</code>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>If you haven&rsquo;t come across <code>World</code> in Cucumber before, it&rsquo;s a way of influencing the context within with a test scenario is run. You don&rsquo;t need to worry about the specifics for this post, as we&rsquo;ll explain them as they become relevant, but if you are interested in the inner workings you can find some tests that document the common uses for it in <a href=https://github.com/cucumber/cucumber-ruby/blob/main/features/docs/writing_support_code/world.feature>the Ruby implementation of Cucumber</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://dvla.github.io/tags/ruby/>Ruby</a></li><li><a href=https://dvla.github.io/tags/testing/>Testing</a></li><li><a href=https://dvla.github.io/tags/cucumber/>Cucumber</a></li><li><a href=https://dvla.github.io/tags/gem/>Gem</a></li></ul><nav class=paginav><a class=next href=https://dvla.github.io/posts/2023-11-linux-timeout-command/><span class=title>Next »</span><br><span>Linux timeout command</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://dvla.github.io/>DVLA Engineering</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>